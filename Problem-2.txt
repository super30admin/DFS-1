//https://leetcode.com/problems/01-matrix/submissions/
// Time Complexity :O(m*n)
// Space Complexity :O(m*n)
// Did this code successfully run on Leetcode :Yes
// Any problem you faced while coding this :

//BFS
// Your code here along with comments explaining your approach
class Solution {
    public int[][] updateMatrix(int[][] mat) {
        
        //null case
        
        if(mat == null || mat.length ==0) return mat;
        
        int m = mat.length;
        int n = mat[0].length;
        int[][] dirs = new int[][] {{0,1}, {1,0},{-1,0},{0,-1}};
        
        Queue<int[]> q = new LinkedList<>();
        
        for(int i =0;i<m;i++)
        {
            for(int j =0;j<n;j++)
            {
                if(mat[i][j] ==0)
                {
                    q.add(new int[]{i,j});
                    
                }
                else{
                    mat[i][j] = -1;
                }
            }
        }
        
        int dist = 1;
        
        while(!q.isEmpty())
        {
            int size = q.size();
            for(int i =0;i<size;i++)
            {
                int[] curr = q.poll();
                for(int[] dir:dirs)
                {
                    int r= curr[0] + dir[0];
                    int c = curr[1] +dir[1];
                    
                    if(r>=0 && r<m && c>=0 && c<n && mat[r][c] ==-1)
                    {
                        mat[r][c] = dist;
                        q.add(new int[]{r,c});
                    }
                }
            }
            dist++;
        }
       return mat;
    }
}


//DFS
// Time Complexity :O(m*n)
// Space Complexity :O(m*n)
// Did this code successfully run on Leetcode :
// Any problem you faced while coding this :
class Solution {
    int m ,n ;
    int[][] result;
    public int[][] updateMatrix(int[][] mat) {
        
        //null case
        
        if(mat == null || mat.length ==0) return mat;
        
         m = mat.length;
         n = mat[0].length;
        
        result = new int[m][n];
        
        for(int i =0 ;i<m;i++){
            for(int j =0 ;j<n;j++){
                result[i][j]=dfs(mat , i , j);
            }
        }
        return result;
    }
    
    private int dfs(int[][] mat , int r , int c){
        
        //base
        if(r<0 || c<0 || r>= m || c>=n) return 9999;
            
        if(mat[r][c] ==0) return mat[r][c];
        
        if(r>0 && mat[r-1][c] == 0)return 1;
        
        if(c>0 && mat[r][c-1] == 0)return 1;
        
        if(r<m-1 && mat[r+1][c] ==0)return 1;
        
        if(c<n-1 && mat[r][c+1] ==0)return 1;
        
        
        //logic
        //no neighbour zero
        int top ,left , right , bottom;
        
        top = left = 9999; // Declare them as infinity
        
         if(r > 0 && result[r-1][c] != 0){

            top = result[r-1][c];
                  }

         if(c > 0 && result[r][c-1] != 0){

            left = result[r][c-1];
            }



       bottom = dfs(mat, r+1, c);

       right = dfs(mat, r, c+1 );



      return Math.min(Math.min(left, right), Math.min(top, bottom)) + 1;


        
    }
        
}

